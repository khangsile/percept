#include <stdio.h>#include <stdlib.h>#include <cv.h>#include <highgui.h>#include <math.h>#include <string.h>#include <time.h>#include "lucasCommon.h"int LucasPerceptShow(double totalTime, int maxPoints, CvCapture **input_video){        	cvQueryFrame( *input_video );            	    	CvSize frame_size;    	frame_size.height =        (int) cvGetCaptureProperty( *input_video, CV_CAP_PROP_FRAME_HEIGHT );    	frame_size.width =        (int) cvGetCaptureProperty( *input_video, CV_CAP_PROP_FRAME_WIDTH );        	long number_of_frames;    	    	cvSetCaptureProperty( *input_video, CV_CAP_PROP_POS_AVI_RATIO, 1. );        	number_of_frames = (int) cvGetCaptureProperty( *input_video, CV_CAP_PROP_POS_FRAMES );    	    	cvSetCaptureProperty( *input_video, CV_CAP_PROP_POS_FRAMES, 0. );                	cvNamedWindow("Optical Flow", CV_WINDOW_AUTOSIZE);    cvNamedWindow("Pixel Cloud", CV_WINDOW_AUTOSIZE);        	long current_frame = 0;        time_t startTime, currentTime;        startTime=time(NULL);            CvFont font;    double hScale=0.5;    double vScale=0.5;    int    lineWidth=1;    cvInitFont(&font,CV_FONT_HERSHEY_SIMPLEX, hScale,vScale,0,lineWidth);        while (true) 	{ 		currentTime=time(NULL);                        static IplImage *frame = NULL, *frame1 = NULL, *frame1_1C = NULL, *frame2_1C = NULL, *eig_image = NULL, *temp_image = NULL, *pyramid1 = NULL, *pyramid2 = NULL;                static IplImage *frame_PC = NULL;        frame_PC = cvCreateImage(cvSize(frame_size.width,frame_size.height),IPL_DEPTH_32F,3);                        			cvSetCaptureProperty( *input_video, CV_CAP_PROP_POS_FRAMES, current_frame );                        				frame = cvQueryFrame( *input_video );        		if (frame == NULL)            		{            		            			fprintf(stderr, "Error: Hmm. The end came sooner than we thought.\n");            cvDestroyWindow("Optical Flow");			return -1;            		}        			allocateOnDemand( &frame1_1C, frame_size, IPL_DEPTH_8U, 1 );        	        		cvConvertImage(frame, frame1_1C);                        		        		allocateOnDemand( &frame1, frame_size, IPL_DEPTH_8U, 3 );        		cvConvertImage(frame, frame1);                		frame = cvQueryFrame( *input_video );        		if (frame == NULL)            		{            			fprintf(stderr, "Error: Hmm. The end came sooner than we thought.\n");            cvDestroyWindow("Optical Flow");			return -1;            		}        		allocateOnDemand( &frame2_1C, frame_size, IPL_DEPTH_8U, 1 );        		cvConvertImage(frame, frame2_1C);                        		allocateOnDemand( &eig_image, frame_size, IPL_DEPTH_32F, 1 );        		allocateOnDemand( &temp_image, frame_size, IPL_DEPTH_32F, 1 );                             		CvPoint2D32f frame1_features[maxPoints];                   		int number_of_features;        		        		        		number_of_features = maxPoints;                                		cvGoodFeaturesToTrack(frame1_1C, eig_image, temp_image, frame1_features, &number_of_features, .01, .01, NULL);                        		        		CvPoint2D32f frame2_features[maxPoints];           		char optical_flow_found_feature[maxPoints];                       		float optical_flow_feature_error[maxPoints];                                		CvSize optical_flow_window = cvSize(3,3);        		        		        		CvTermCriteria optical_flow_termination_criteria                = cvTermCriteria( CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 20, .3 );                        		        		allocateOnDemand( &pyramid1, frame_size, IPL_DEPTH_8U, 1 );        		allocateOnDemand( &pyramid2, frame_size, IPL_DEPTH_8U, 1 );                        				cvCalcOpticalFlowPyrLK(frame1_1C, frame2_1C, pyramid1, pyramid2, frame1_features, frame2_features, number_of_features, optical_flow_window, 5, optical_flow_found_feature, optical_flow_feature_error, optical_flow_termination_criteria, 0 );        		        		for(int i = 0; i < number_of_features; i++)            		{            			            			if ( optical_flow_found_feature[i] == 0 )	continue;                                    			int line_thickness;				line_thickness = 1;            			            			CvScalar line_color;			line_color = CV_RGB(255,0,0);                                    			            			CvPoint p,q;            			p.x = (int) frame1_features[i].x;            			p.y = (int) frame1_features[i].y;            			q.x = (int) frame2_features[i].x;            			q.y = (int) frame2_features[i].y;                                    			double angle;		angle = atan2( (double) p.y - q.y, (double) p.x - q.x );            			double hypotenuse;	hypotenuse = sqrt( square(p.y - q.y) + square(p.x - q.x) );                                    		            			q.x = (int) (p.x - 3 * hypotenuse * cos(angle));            			q.y = (int) (p.y - 3 * hypotenuse * sin(angle));                                                			cvLine( frame1, p, q, line_color, line_thickness, CV_AA, 0 );            						            			p.x = (int) (q.x + 9 * cos(angle + pi / 4));            			p.y = (int) (q.y + 9 * sin(angle + pi / 4));            			cvLine( frame1, p, q, line_color, line_thickness, CV_AA, 0 );            			p.x = (int) (q.x + 9 * cos(angle - pi / 4));            			p.y = (int) (q.y + 9 * sin(angle - pi / 4));            			cvLine( frame1, p, q, line_color, line_thickness, CV_AA, 0 );                                            CvScalar point_color;                                      int mag = int(hypotenuse);             char str[10];             sprintf(str, "%d", mag);             point_color = CV_RGB(mag,mag,mag);             cvPutText(frame_PC,str,p,&font,line_color);             cvCircle(frame_PC, p, 2, point_color,-1,CV_AA,0);                         		}        		        		cvShowImage("Optical Flow", frame1);        cvShowImage("Pixel Cloud", frame_PC);        		if (difftime(currentTime,startTime)>=totalTime) {                        cvDestroyWindow("Optical Flow");            cvDestroyWindow("Pixel Cloud");                        FILE *fp;            fp = fopen("percept.TXT","w"); /* open for writing */            fprintf(fp,"Point X\tPoint Y\tMagnitude\n");                        for(int i=0;i<number_of_features;i++)            {                                CvPoint p,q;                                p.x = (int) frame1_features[i].x;                                p.y = (int) frame1_features[i].y;                                q.x = (int) frame2_features[i].x;                                q.y = (int) frame2_features[i].y;                                double hypotenuse; hypotenuse = sqrt( square(p.y - q.y) + square(p.x - q.x) );                                                fprintf(fp,"%d\t%d\t%f\n",p.x,p.y,hypotenuse);            }                        fclose(fp);            cvSaveImage("frame.png",frame1);            cvSaveImage("framePC.png",frame_PC);                        return 0;        }                        		int key_pressed;        		key_pressed = cvWaitKey(0);                        		                		if (key_pressed == 'b' || key_pressed == 'B')	current_frame--;        		else                                            current_frame++;                	        		if (current_frame < 0)						current_frame = 0;        		if (current_frame >= number_of_frames - 1)	current_frame = number_of_frames - 2;        	}        cvDestroyWindow("Optical Flow");    return 0;    }