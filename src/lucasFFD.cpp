#include <stdio.h>#include <stdlib.h>#include <cv.h>#include <highgui.h>#include <math.h>#include <string.h>#include <time.h>#include "lucasCommon.h"#include "dsPercept.hpp"int LucasPerceptFFD(double totalTime, int maxPoints, CvCapture **input_video, pcMatrixPercept* diffMatrix){	        cvQueryFrame( *input_video );	CvSize frame_size;	frame_size.height =		(int) cvGetCaptureProperty( *input_video, CV_CAP_PROP_FRAME_HEIGHT );	frame_size.width =		(int) cvGetCaptureProperty( *input_video, CV_CAP_PROP_FRAME_WIDTH );     	long number_of_frames;		cvSetCaptureProperty( *input_video, CV_CAP_PROP_POS_AVI_RATIO, 1. );		number_of_frames = (int) cvGetCaptureProperty( *input_video, CV_CAP_PROP_POS_FRAMES );		cvSetCaptureProperty( *input_video, CV_CAP_PROP_POS_FRAMES, 0. );	long current_frame = 0;        time_t startTime, currentTime;        startTime=time(NULL);        diffMatrix->pcMatrixInit(frame_size);        CvFont font;    double hScale=0.5;    double vScale=0.5;    int    lineWidth=1;    cvInitFont(&font,CV_FONT_HERSHEY_SIMPLEX, hScale,vScale,0,lineWidth);        int flag=0;    printf("\nLucas working..\n");        while (true) 	{ 		currentTime=time(NULL);                if (difftime(currentTime,startTime)>=totalTime) {                        static IplImage *frame_draw = NULL;            CvScalar point_color;            CvPoint p;            frame_draw = cvCreateImage(cvSize(frame_size.width,frame_size.height),IPL_DEPTH_32F,3);                        for (int i=0; i<frame_size.height; i++)             {                for (int j=0; j<frame_size.width; j++)                {                    p.x=j;                    p.y=i;                    int value = diffMatrix->getRelDepth(j,i);                    point_color = CV_RGB(value,value,value);                    cvCircle(frame_draw, p, 1, point_color,-1,CV_AA,0);                 }            }                        cvSaveImage("frameDraw.png",frame_draw);                        return 0;        }        static IplImage *frame = NULL, *frame1 = NULL, *frame1_1C = NULL, *frame2_1C = NULL, *eig_image = NULL, *temp_image = NULL, *pyramid1 = NULL, *pyramid2 = NULL;        		cvSetCaptureProperty( *input_video, CV_CAP_PROP_POS_FRAMES, current_frame );        if(flag==0)        {            		frame = cvQueryFrame( *input_video );		if (frame == NULL)		{						fprintf(stderr, "Error: Hmm. The end came sooner than we thought.\n");        			return -1;		}				allocateOnDemand( &frame1_1C, frame_size, IPL_DEPTH_8U, 1 );		cvConvertImage(frame, frame1_1C);		allocateOnDemand( &frame1, frame_size, IPL_DEPTH_8U, 3 );		cvConvertImage(frame, frame1);                    flag=1;                    }		frame = cvQueryFrame( *input_video );		if (frame == NULL)		{			fprintf(stderr, "Error: Hmm. The end came sooner than we thought.\n");             			return -1;		}		allocateOnDemand( &frame2_1C, frame_size, IPL_DEPTH_8U, 1 );		cvConvertImage(frame, frame2_1C);			allocateOnDemand( &eig_image, frame_size, IPL_DEPTH_32F, 1 );		allocateOnDemand( &temp_image, frame_size, IPL_DEPTH_32F, 1 );		CvPoint2D32f frame1_features[maxPoints];				int number_of_features;						number_of_features = maxPoints;		cvGoodFeaturesToTrack(frame1_1C, eig_image, temp_image, frame1_features, &number_of_features, .01, .01, NULL);		CvPoint2D32f frame2_features[maxPoints];		char optical_flow_found_feature[maxPoints];		float optical_flow_feature_error[maxPoints];		CvSize optical_flow_window = cvSize(3,3);				CvTermCriteria optical_flow_termination_criteria			= cvTermCriteria( CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 20, .3 );		allocateOnDemand( &pyramid1, frame_size, IPL_DEPTH_8U, 1 );		allocateOnDemand( &pyramid2, frame_size, IPL_DEPTH_8U, 1 );			cvCalcOpticalFlowPyrLK(frame1_1C, frame2_1C, pyramid1, pyramid2, frame1_features, frame2_features, number_of_features, optical_flow_window, 5, optical_flow_found_feature, optical_flow_feature_error, optical_flow_termination_criteria, 0 );		       		for(int i = 0; i < number_of_features; i++)		{			if ( optical_flow_found_feature[i] == 0 )	continue;			int line_thickness;				line_thickness = 1;						CvScalar line_color;			line_color = CV_RGB(255,0,0);							CvPoint p,q;			p.x = (int) frame1_features[i].x;			p.y = (int) frame1_features[i].y;			q.x = (int) frame2_features[i].x;			q.y = (int) frame2_features[i].y;			double hypotenuse;	hypotenuse = sqrt( square(p.y - q.y) + square(p.x - q.x) );            diffMatrix->addRelDepth(p.x,p.y,(int)hypotenuse);      		}                             		if (current_frame < 0)						current_frame = 0;		if (current_frame >= number_of_frames - 1)	current_frame = number_of_frames - 2;	}        return 0;}